import {
  Icon
} from "./chunk-YKV3TIX6.js";
import {
  Overlay,
  Portal_default,
  isObject,
  localeable,
  pickEventsProps,
  require_identity,
  themeable,
  uncontrollable
} from "./chunk-E64EENQX.js";
import {
  __assign,
  __extends,
  __rest
} from "./chunk-N4FYP52A.js";
import {
  types
} from "./chunk-TJNQ6KM7.js";
import {
  observable,
  reaction
} from "./chunk-KYA7D7YK.js";
import {
  _inheritsLoose,
  require_prop_types
} from "./chunk-DVRASE46.js";
import {
  require_react_dom
} from "./chunk-3QPCRVPD.js";
import {
  _objectWithoutPropertiesLoose
} from "./chunk-Y67KMEH3.js";
import {
  require_react
} from "./chunk-AIVQU27O.js";
import {
  __commonJS,
  __toESM
} from "./chunk-LFBQMW2U.js";

// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/lodash/_castFunction.js"(exports, module) {
    var identity = require_identity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    module.exports = castFunction;
  }
});

// node_modules/amis-ui/esm/components/Html.js
var import_react = __toESM(require_react());
var Html = (
  /** @class */
  function(_super) {
    __extends(Html2, _super);
    function Html2(props) {
      var _this = _super.call(this, props) || this;
      _this.htmlRef = _this.htmlRef.bind(_this);
      return _this;
    }
    Html2.prototype.componentDidUpdate = function(prevProps) {
      if (this.props.html !== prevProps.html) {
        this._render();
      }
    };
    Html2.prototype.htmlRef = function(dom) {
      this.dom = dom;
      if (!dom) {
        return;
      }
      this._render();
    };
    Html2.prototype._render = function() {
      var _a3 = this.props, html = _a3.html, filterHtml = _a3.filterHtml;
      if (html) {
        this.dom.innerHTML = filterHtml ? filterHtml(html) : html;
      }
    };
    Html2.prototype.render = function() {
      var _a3 = this.props, className = _a3.className, wrapperComponent = _a3.wrapperComponent, inline = _a3.inline;
      _a3.classPrefix;
      var cx = _a3.classnames;
      var Component = wrapperComponent || (inline ? "span" : "div");
      return import_react.default.createElement(Component, { ref: this.htmlRef, className: cx("Html", className) });
    };
    Html2.defaultProps = {
      inline: true
    };
    return Html2;
  }(import_react.default.Component)
);
var Html$1 = themeable(Html);

// node_modules/amis-ui/esm/components/Tooltip.js
var import_react2 = __toESM(require_react());
var Tooltip = (
  /** @class */
  function(_super) {
    __extends(Tooltip2, _super);
    function Tooltip2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Tooltip2.prototype.render = function() {
      var _a3 = this.props;
      _a3.classPrefix;
      var className = _a3.className, tooltipTheme = _a3.tooltipTheme, title = _a3.title, children = _a3.children, arrowProps = _a3.arrowProps, style = _a3.style;
      _a3.placement;
      _a3.arrowOffsetLeft;
      _a3.arrowOffsetTop;
      _a3.positionLeft;
      _a3.positionTop;
      var cx = _a3.classnames, activePlacement = _a3.activePlacement, showArrow = _a3.showArrow, onMouseEnter = _a3.onMouseEnter, onMouseLeave = _a3.onMouseLeave, bodyClassName = _a3.bodyClassName, rest = __rest(_a3, ["classPrefix", "className", "tooltipTheme", "title", "children", "arrowProps", "style", "placement", "arrowOffsetLeft", "arrowOffsetTop", "positionLeft", "positionTop", "classnames", "activePlacement", "showArrow", "onMouseEnter", "onMouseLeave", "bodyClassName"]);
      return import_react2.default.createElement(
        "div",
        __assign({}, rest, { className: cx("Tooltip", activePlacement ? "Tooltip--".concat(activePlacement) : "", className, "Tooltip--".concat(tooltipTheme === "dark" ? "dark" : "light")), style, onMouseEnter, onMouseLeave, role: "tooltip" }),
        showArrow ? import_react2.default.createElement("div", __assign({ className: cx("Tooltip-arrow") }, arrowProps)) : null,
        title ? import_react2.default.createElement("div", { className: cx("Tooltip-title") }, title) : null,
        import_react2.default.createElement("div", { className: cx(bodyClassName, "Tooltip-body") }, children)
      );
    };
    Tooltip2.defaultProps = {
      className: "",
      tooltipTheme: "light",
      showArrow: true
    };
    return Tooltip2;
  }(import_react2.default.Component)
);
var Tooltip$1 = themeable(Tooltip);

// node_modules/amis-ui/esm/components/TooltipWrapper.js
var import_react3 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var waitToHide = null;
var TooltipWrapper = (
  /** @class */
  function(_super) {
    __extends(TooltipWrapper2, _super);
    function TooltipWrapper2(props) {
      var _this = _super.call(this, props) || this;
      _this.moutned = true;
      _this.tooltipMouseEnter = function(e) {
        var _a3;
        var tooltip = _this.props.tooltip;
        var enterable = (_a3 = tooltip === null || tooltip === void 0 ? void 0 : tooltip.enterable) !== null && _a3 !== void 0 ? _a3 : true;
        enterable && clearTimeout(_this.timer);
      };
      _this.tooltipMouseLeave = function(e) {
        var _a3;
        var tooltip = _this.props.tooltip;
        var enterable = (_a3 = tooltip === null || tooltip === void 0 ? void 0 : tooltip.enterable) !== null && _a3 !== void 0 ? _a3 : true;
        enterable && clearTimeout(_this.timer);
        _this.hide();
      };
      _this.getTarget = _this.getTarget.bind(_this);
      _this.show = _this.show.bind(_this);
      _this.hide = _this.hide.bind(_this);
      _this.handleShow = _this.handleShow.bind(_this);
      _this.handleHide = _this.handleHide.bind(_this);
      _this.handleClick = _this.handleClick.bind(_this);
      _this.handleFocus = _this.handleFocus.bind(_this);
      _this.handleBlur = _this.handleBlur.bind(_this);
      _this.handleMouseOver = _this.handleMouseOver.bind(_this);
      _this.handleMouseOut = _this.handleMouseOut.bind(_this);
      _this.state = {
        show: false
      };
      return _this;
    }
    TooltipWrapper2.prototype.componentWillUnmount = function() {
      clearTimeout(this.timer);
      this.moutned = false;
    };
    TooltipWrapper2.prototype.getTarget = function() {
      return (0, import_react_dom.findDOMNode)(this);
    };
    TooltipWrapper2.prototype.show = function() {
      var _this = this;
      this.setState({
        show: true
      }, function() {
        if (_this.props.onVisibleChange) {
          _this.props.onVisibleChange(true);
        }
      });
    };
    TooltipWrapper2.prototype.hide = function() {
      var _this = this;
      waitToHide = null;
      this.moutned && this.setState({
        show: false
      }, function() {
        if (_this.props.onVisibleChange) {
          _this.props.onVisibleChange(false);
        }
      });
    };
    TooltipWrapper2.prototype.getChildProps = function() {
      var child = import_react3.default.Children.only(this.props.children);
      return child && child.props;
    };
    TooltipWrapper2.prototype.handleShow = function() {
      this.timer && clearTimeout(this.timer);
      waitToHide && waitToHide();
      var tooltip = this.props.tooltip;
      if (isObject(tooltip)) {
        var _a3 = tooltip.mouseEnterDelay, mouseEnterDelay = _a3 === void 0 ? 0 : _a3;
        this.timer = setTimeout(this.show, mouseEnterDelay);
      } else {
        this.timer = setTimeout(this.show, 0);
      }
    };
    TooltipWrapper2.prototype.handleHide = function() {
      clearTimeout(this.timer);
      var _a3 = this.props, delay = _a3.delay, tooltip = _a3.tooltip;
      waitToHide = this.hide.bind(this);
      if (isObject(tooltip)) {
        var _b = tooltip.mouseLeaveDelay, mouseLeaveDelay = _b === void 0 ? 300 : _b;
        this.timer = setTimeout(this.hide, mouseLeaveDelay);
      } else {
        this.timer = setTimeout(this.hide, delay);
      }
    };
    TooltipWrapper2.prototype.handleFocus = function(e) {
      var onFocus = this.getChildProps().onFocus;
      this.handleShow();
      onFocus && onFocus(e);
    };
    TooltipWrapper2.prototype.handleBlur = function(e) {
      var onBlur = this.getChildProps().onBlur;
      this.handleHide();
      onBlur && onBlur(e);
    };
    TooltipWrapper2.prototype.handleMouseOver = function(e) {
      this.handleMouseOverOut(this.handleShow, e, "fromElement");
    };
    TooltipWrapper2.prototype.handleMouseOut = function(e) {
      this.handleMouseOverOut(this.handleHide, e, "toElement");
    };
    TooltipWrapper2.prototype.handleMouseOverOut = function(handler, e, relatedNative) {
      var target = e.currentTarget;
      var related = e.relatedTarget || e.nativeEvent[relatedNative];
      if ((!related || related !== target) && !target.contains(related)) {
        handler(e);
      }
    };
    TooltipWrapper2.prototype.handleClick = function(e) {
      var onClick = this.getChildProps().onClick;
      this.state.show ? this.hide() : this.show();
      onClick && onClick(e);
    };
    TooltipWrapper2.prototype.render = function() {
      var props = this.props;
      var child = import_react3.default.Children.only(props.children);
      if (!props.tooltip) {
        return child;
      }
      var tooltipObj = __assign({ placement: props.placement, container: props.container, trigger: props.trigger, rootClose: props.rootClose, tooltipClassName: props.tooltipClassName, style: props.style, mouseLeaveDelay: props.delay, tooltipTheme: props.tooltipTheme }, typeof props.tooltip === "string" ? { content: props.tooltip } : props.tooltip);
      var title = tooltipObj.title, content = tooltipObj.content, placement = tooltipObj.placement, container = tooltipObj.container, trigger = tooltipObj.trigger, rootClose = tooltipObj.rootClose, tooltipClassName = tooltipObj.tooltipClassName, tooltipBodyClassName = tooltipObj.tooltipBodyClassName, style = tooltipObj.style, _a3 = tooltipObj.disabled, disabled = _a3 === void 0 ? false : _a3, offset = tooltipObj.offset, _b = tooltipObj.tooltipTheme, tooltipTheme = _b === void 0 ? "light" : _b, _c = tooltipObj.showArrow, showArrow = _c === void 0 ? true : _c, children = tooltipObj.children, filterHtml = tooltipObj.filterHtml;
      var childProps = {
        key: "target"
      };
      var triggers = Array.isArray(trigger) ? trigger.concat() : [trigger];
      if (~triggers.indexOf("click")) {
        childProps.onClick = this.handleClick;
      }
      if (~triggers.indexOf("focus")) {
        childProps.onFocus = this.handleShow;
        childProps.onBlur = this.handleHide;
      }
      if (~triggers.indexOf("hover")) {
        childProps.onMouseOver = this.handleMouseOver;
        childProps.onMouseOut = this.handleMouseOut;
      }
      return [
        child ? import_react3.default.cloneElement(child, childProps) : null,
        import_react3.default.createElement(
          Overlay,
          { key: "overlay", target: this.getTarget, show: this.state.show && !disabled, onHide: this.handleHide, rootClose, placement, container, offset: Array.isArray(offset) ? offset : [0, 0] },
          import_react3.default.createElement(Tooltip$1, { title: typeof title === "string" ? title : void 0, style, className: tooltipClassName, tooltipTheme, showArrow, bodyClassName: tooltipBodyClassName, onMouseEnter: ~triggers.indexOf("hover") ? this.tooltipMouseEnter : function() {
          }, onMouseLeave: ~triggers.indexOf("hover") ? this.tooltipMouseLeave : function() {
          } }, children ? import_react3.default.createElement(import_react3.default.Fragment, null, typeof children === "function" ? children() : children) : import_react3.default.createElement(Html$1, { html: typeof content === "string" ? content : "", filterHtml }))
        )
      ];
    };
    TooltipWrapper2.defaultProps = {
      placement: "top",
      trigger: ["hover", "focus"],
      rootClose: false,
      delay: 300
    };
    return TooltipWrapper2;
  }(import_react3.default.Component)
);
var TooltipWrapper$1 = themeable(uncontrollable(TooltipWrapper, {
  show: "onVisibleChange"
}));

// node_modules/amis-ui/esm/components/Spinner.js
var import_react6 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// node_modules/react-transition-group/esm/Transition.js
var import_prop_types2 = __toESM(require_prop_types());
var import_react5 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/react-transition-group/esm/config.js
var config_default = {
  disabled: false
};

// node_modules/react-transition-group/esm/utils/PropTypes.js
var import_prop_types = __toESM(require_prop_types());
var timeoutsShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
  enter: import_prop_types.default.number,
  exit: import_prop_types.default.number,
  appear: import_prop_types.default.number
}).isRequired]) : null;
var classNamesShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.shape({
  enter: import_prop_types.default.string,
  exit: import_prop_types.default.string,
  active: import_prop_types.default.string
}), import_prop_types.default.shape({
  enter: import_prop_types.default.string,
  enterDone: import_prop_types.default.string,
  enterActive: import_prop_types.default.string,
  exit: import_prop_types.default.string,
  exitDone: import_prop_types.default.string,
  exitActive: import_prop_types.default.string
})]) : null;

// node_modules/react-transition-group/esm/TransitionGroupContext.js
var import_react4 = __toESM(require_react());
var TransitionGroupContext_default = import_react4.default.createContext(null);

// node_modules/react-transition-group/esm/Transition.js
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom2.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config_default.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : import_react_dom2.default.findDOMNode(this);
    if (!exit || config_default.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom2.default.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      import_react5.default.createElement(TransitionGroupContext_default.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : import_react5.default.cloneElement(import_react5.default.Children.only(children), childProps))
    );
  };
  return Transition2;
}(import_react5.default.Component);
Transition.contextType = TransitionGroupContext_default;
Transition.propTypes = true ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: import_prop_types2.default.shape({
    current: typeof Element === "undefined" ? import_prop_types2.default.any : function(propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return import_prop_types2.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: import_prop_types2.default.oneOfType([import_prop_types2.default.func.isRequired, import_prop_types2.default.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: import_prop_types2.default.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: import_prop_types2.default.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: import_prop_types2.default.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: import_prop_types2.default.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: import_prop_types2.default.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: import_prop_types2.default.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener)
      pt = pt.isRequired;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return pt.apply(void 0, [props].concat(args));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: import_prop_types2.default.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: import_prop_types2.default.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: import_prop_types2.default.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: import_prop_types2.default.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: import_prop_types2.default.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: import_prop_types2.default.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: import_prop_types2.default.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition_default = Transition;

// node_modules/amis-ui/esm/components/Spinner.js
var _a;
var fadeStyles = (_a = {}, _a[ENTERED] = "in", _a[ENTERING] = "in", _a);
var SpinnerSharedStore = types.model("SpinnerSharedStore", {}).volatile(function(self) {
  return {
    // 保存所有可以进入 loading 状态（props.show = true）的 Spinner 的父级容器
    spinningContainers: observable.set([], {
      deep: false
    })
  };
}).actions(function(self) {
  return {
    push: function(spinnerContainer) {
      if (self.spinningContainers.has(spinnerContainer)) {
        return;
      }
      self.spinningContainers.add(spinnerContainer);
    },
    remove: function(spinnerContainer) {
      if (self.spinningContainers.has(spinnerContainer)) {
        self.spinningContainers.delete(spinnerContainer);
      }
    },
    /**
     *  判断当前 Spinner 是否可以进入 loading 状态
     * @param spinnerContainerWillCheck 待检查的 Spinner 父容器
     * @returns {boolean} 是否可以进入 loading
     */
    checkLoading: function(spinnerContainerWillCheck) {
      if (self.spinningContainers.has(spinnerContainerWillCheck)) {
        if (!self.spinningContainers.size) {
          return false;
        }
        var loading_1 = true;
        self.spinningContainers.forEach(function(container) {
          if (container.contains(spinnerContainerWillCheck) && container !== spinnerContainerWillCheck) {
            loading_1 = false;
          }
        });
        return loading_1;
      }
      return false;
    }
  };
});
var store = SpinnerSharedStore.create({});
var Spinner = (
  /** @class */
  function(_super) {
    __extends(Spinner2, _super);
    function Spinner2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.state = {
        spinning: false,
        showMarker: true
      };
      _this.parent = null;
      _this.loadingTriggered = false;
      _this.spinnerRef = function(dom) {
        if (dom) {
          _this.parent = dom.parentNode;
        }
      };
      _this.loadingChecker = reaction(function() {
        return store.spinningContainers.size;
      }, function() {
        if (_this.parent) {
          _this.setState({
            spinning: store.checkLoading(_this.parent) && _this.loadingTriggered
          });
        }
      });
      return _this;
    }
    Spinner2.prototype.componentDidUpdate = function() {
      var _a3, _b;
      var showLoading = ((_a3 = this.props.loadingConfig) === null || _a3 === void 0 ? void 0 : _a3.show) === true || typeof ((_b = this.props.loadingConfig) === null || _b === void 0 ? void 0 : _b.show) === "undefined";
      if (this.parent && showLoading) {
        if (this.props.show) {
          this.loadingTriggered = true;
          store.push(this.parent);
        } else if (this.state.spinning && this.loadingTriggered) {
          this.loadingTriggered = false;
          store.remove(this.parent);
        }
      }
    };
    Spinner2.prototype.componentDidMount = function() {
      if (this.parent && this.state.showMarker) {
        this.setState({ showMarker: false });
      }
    };
    Spinner2.prototype.componentWillUnmount = function() {
      this.loadingChecker();
      store.remove(this.parent);
    };
    Spinner2.prototype.renderBody = function() {
      var _a3 = this.props, cx = _a3.classnames, className = _a3.className, spinnerClassName = _a3.spinnerClassName, _b = _a3.size, size = _b === void 0 ? "" : _b, overlay = _a3.overlay, delay = _a3.delay, iconConfig = _a3.icon, tip = _a3.tip, _c = _a3.tipPlacement, tipPlacement = _c === void 0 ? "" : _c, loadingConfig = _a3.loadingConfig, disabled = _a3.disabled;
      var icon = (loadingConfig === null || loadingConfig === void 0 ? void 0 : loadingConfig.root) ? void 0 : iconConfig;
      var isCustomIcon = icon && import_react6.default.isValidElement(icon);
      var timeout2 = { enter: delay, exit: 0 };
      var showOverlay = (loadingConfig === null || loadingConfig === void 0 ? void 0 : loadingConfig.root) || overlay;
      return import_react6.default.createElement(
        import_react6.default.Fragment,
        null,
        this.state.showMarker && import_react6.default.createElement("span", { className: cx("Spinner-mark"), ref: this.spinnerRef }),
        import_react6.default.createElement(Transition_default, { mountOnEnter: true, unmountOnExit: true, in: this.state.spinning, timeout: timeout2 }, function(status) {
          var _a4, _b2, _c2;
          return import_react6.default.createElement(
            import_react6.default.Fragment,
            null,
            showOverlay ? import_react6.default.createElement("div", { className: cx("Spinner-overlay", fadeStyles[status]) }) : null,
            import_react6.default.createElement(
              "div",
              { "data-testid": "spinner", className: cx("Spinner", tip && (_a4 = {}, _a4["Spinner-tip--".concat(tipPlacement)] = [
                "top",
                "right",
                "bottom",
                "left"
              ].includes(tipPlacement), _a4), (_b2 = {}, _b2["Spinner--overlay"] = showOverlay, _b2), fadeStyles[status], className) },
              import_react6.default.createElement("div", { className: cx("Spinner-icon", (_c2 = {}, _c2["Spinner-icon--".concat(size)] = ["lg", "sm"].includes(size), _c2["Spinner-icon--default"] = !icon, _c2["Spinner-icon--simple"] = !isCustomIcon && icon, _c2["Spinner-icon--custom"] = isCustomIcon, _c2["Spinner-icon--disabled"] = disabled, _c2), spinnerClassName) }, icon ? import_react6.default.createElement(Icon, { cx, icon, className: "icon" }) : null),
              tip ? import_react6.default.createElement("span", { className: cx("Spinner-tip") }, tip) : ""
            )
          );
        })
      );
    };
    Spinner2.prototype.render = function() {
      var loadingConfig = this.props.loadingConfig;
      var spinnerBody = this.renderBody();
      var root = loadingConfig === null || loadingConfig === void 0 ? void 0 : loadingConfig.root;
      var dom = root ? document.querySelector(root) : null;
      if (dom) {
        return import_react_dom3.default.createPortal(spinnerBody, dom);
      }
      return spinnerBody;
    };
    Spinner2.defaultProps = {
      show: true,
      className: "",
      spinnerClassName: "",
      size: "",
      icon: "",
      tip: "",
      tipPlacement: "bottom",
      delay: 0,
      overlay: false,
      loadingConfig: {},
      disabled: false
    };
    return Spinner2;
  }(import_react6.default.Component)
);
var Spinner$1 = themeable(Spinner);

// node_modules/amis-ui/esm/components/Button.js
var import_react7 = __toESM(require_react());
var Button = (
  /** @class */
  function(_super) {
    __extends(Button2, _super);
    function Button2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Button2.prototype.renderButton = function() {
      var _a3, _b;
      var _c = this.props, level = _c.level, _d = _c.size, size = _d === void 0 ? "default" : _d, disabled = _c.disabled, className = _c.className, style = _c.style, title = _c.title, Comp = _c.componentClass, cx = _c.classnames, children = _c.children;
      _c.disabledTip;
      var block = _c.block, type = _c.type, active = _c.active, iconOnly = _c.iconOnly, href = _c.href, loading = _c.loading, loadingClassName = _c.loadingClassName, overrideClassName = _c.overrideClassName, loadingConfig = _c.loadingConfig, rest = __rest(_c, ["level", "size", "disabled", "className", "style", "title", "componentClass", "classnames", "children", "disabledTip", "block", "type", "active", "iconOnly", "href", "loading", "loadingClassName", "overrideClassName", "loadingConfig"]);
      if (href) {
        Comp = "a";
      } else if (Comp === "button" && disabled || loading) {
        Comp = "div";
      }
      return import_react7.default.createElement(
        Comp,
        __assign({ type: Comp === "input" || Comp === "button" ? type : void 0 }, pickEventsProps(rest), { onClick: rest.onClick && disabled ? function() {
        } : rest.onClick, href, className: cx(overrideClassName ? "" : (_a3 = {
          "Button": true
        }, _a3["Button--".concat(level)] = level, _a3["Button--size-".concat(size)] = size, _a3["Button--block"] = block, _a3["Button--iconOnly"] = iconOnly, _a3["is-disabled"] = disabled, _a3["is-active"] = active, _a3), className), style, title, disabled }),
        loading && !disabled && import_react7.default.createElement(Spinner$1, { loadingConfig, size: "sm", show: true, icon: "loading-outline", className: cx(overrideClassName ? "" : (_b = {}, _b["Button--loading Button--loading--".concat(level)] = level, _b), loadingClassName) }),
        children
      );
    };
    Button2.prototype.render = function() {
      var _a3 = this.props, tooltip = _a3.tooltip, tooltipPlacement = _a3.tooltipPlacement, tooltipContainer = _a3.tooltipContainer, tooltipTrigger = _a3.tooltipTrigger, tooltipRootClose = _a3.tooltipRootClose, disabled = _a3.disabled, disabledTip = _a3.disabledTip;
      _a3.classnames;
      return import_react7.default.createElement(TooltipWrapper$1, { placement: tooltipPlacement, tooltip: disabled ? disabledTip : tooltip, container: tooltipContainer, trigger: tooltipTrigger, rootClose: tooltipRootClose }, this.renderButton());
    };
    Button2.defaultProps = {
      componentClass: "button",
      level: "default",
      type: "button",
      tooltipPlacement: "top",
      tooltipTrigger: ["hover", "focus"],
      tooltipRootClose: false
    };
    return Button2;
  }(import_react7.default.Component)
);
var Button$1 = themeable(Button);

// node_modules/amis-ui/esm/components/PopUp.js
var import_react8 = __toESM(require_react());
var _a2;
var fadeStyles2 = (_a2 = {}, _a2[ENTERED] = "", _a2[EXITING] = "out", _a2[EXITED] = "", _a2[ENTERING] = "in", _a2);
var PopUp = (
  /** @class */
  function(_super) {
    __extends(PopUp2, _super);
    function PopUp2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.scrollTop = 0;
      return _this;
    }
    PopUp2.prototype.componentDidUpdate = function() {
      if (this.props.isShow) {
        this.scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
        document.body.style.overflow = "hidden";
      } else {
        document.body.style.overflow = "auto";
        document.body.scrollTop = this.scrollTop;
      }
    };
    PopUp2.prototype.componentWillUnmount = function() {
      document.body.style.overflow = "auto";
      document.body.scrollTop = this.scrollTop;
    };
    PopUp2.prototype.handleClick = function(e) {
      e.stopPropagation();
    };
    PopUp2.prototype.render = function() {
      var _this = this;
      var _a3 = this.props, style = _a3.style, title = _a3.title, children = _a3.children, overlay = _a3.overlay, onHide = _a3.onHide, onConfirm = _a3.onConfirm, ns = _a3.classPrefix, cx = _a3.classnames, className = _a3.className, isShow = _a3.isShow, container = _a3.container, showConfirm = _a3.showConfirm, __ = _a3.translate, showClose = _a3.showClose, header = _a3.header, _b = _a3.placement, placement = _b === void 0 ? "center" : _b, rest = __rest(_a3, ["style", "title", "children", "overlay", "onHide", "onConfirm", "classPrefix", "classnames", "className", "isShow", "container", "showConfirm", "translate", "showClose", "header", "placement"]);
      var outerStyle = __assign({}, style);
      delete outerStyle.top;
      return import_react8.default.createElement(
        Portal_default,
        { container },
        import_react8.default.createElement(Transition_default, { mountOnEnter: true, unmountOnExit: true, in: isShow, timeout: 500, appear: true }, function(status) {
          return import_react8.default.createElement(
            "div",
            __assign({ className: cx("".concat(ns, "PopUp"), className, fadeStyles2[status]), style: outerStyle }, rest, { onClick: _this.handleClick }),
            overlay && import_react8.default.createElement("div", { className: "".concat(ns, "PopUp-overlay"), onClick: onHide }),
            import_react8.default.createElement(
              "div",
              { className: cx("".concat(ns, "PopUp-inner")) },
              !showConfirm && showClose ? import_react8.default.createElement(
                "div",
                { className: cx("".concat(ns, "PopUp-closeWrap")) },
                header,
                import_react8.default.createElement(
                  "span",
                  { className: cx("PopUp-closeBox"), onClick: onHide },
                  import_react8.default.createElement(Icon, { icon: "close", className: cx("icon", "".concat(ns, "PopUp-close")) })
                )
              ) : null,
              showConfirm && import_react8.default.createElement(
                "div",
                { className: cx("".concat(ns, "PopUp-toolbar")) },
                import_react8.default.createElement(Button$1, { className: cx("".concat(ns, "PopUp-cancel")), level: "link", onClick: onHide }, __("cancel")),
                title && import_react8.default.createElement("span", { className: cx("".concat(ns, "PopUp-title")) }, title),
                import_react8.default.createElement(Button$1, { className: cx("".concat(ns, "PopUp-confirm")), level: "link", onClick: onConfirm }, __("confirm"))
              ),
              import_react8.default.createElement("div", { className: cx("".concat(ns, "PopUp-content"), "justify-".concat(placement)) }, isShow ? children : null),
              import_react8.default.createElement("div", { className: cx("PopUp-safearea") })
            )
          );
        })
      );
    };
    PopUp2.defaultProps = {
      className: "",
      overlay: true,
      isShow: false,
      container: document.body,
      showClose: true,
      onConfirm: function() {
      }
    };
    return PopUp2;
  }(import_react8.default.PureComponent)
);
var PopUp$1 = themeable(localeable(PopUp));

export {
  EXITED,
  ENTERING,
  ENTERED,
  EXITING,
  Transition_default,
  Html$1,
  Tooltip$1,
  TooltipWrapper$1,
  Spinner,
  Spinner$1,
  Button$1,
  PopUp$1,
  require_castFunction
};
//# sourceMappingURL=chunk-VBZCWK4Q.js.map
