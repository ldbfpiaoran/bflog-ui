/**
 * amis-core v3.6.3
 * Copyright 2018-2023 fex
 */

import { __read } from 'tslib';
import ReactDOM from 'react-dom';
import React from 'react';
import { offset } from './offset.js';
import { position } from './position.js';

function getContainer(container, defaultContainer) {
    container = typeof container === 'function' ? container() : container;
    return ReactDOM.findDOMNode(container) || defaultContainer;
}
function ownerDocument(componentOrElement) {
    var _a;
    return (((_a = ReactDOM.findDOMNode(componentOrElement)) === null || _a === void 0 ? void 0 : _a.ownerDocument) ||
        document);
}
function getContainerDimensions(containerNode) {
    var _a;
    var width, height, scroll;
    if (containerNode.tagName === 'BODY') {
        width = window.innerWidth;
        height = window.innerHeight;
        scroll =
            ownerDocument(containerNode).documentElement.scrollTop ||
                (containerNode === null || containerNode === void 0 ? void 0 : containerNode.scrollTop);
    }
    else {
        (_a = offset(containerNode), width = _a.width, height = _a.height);
        scroll = containerNode.scrollTop;
    }
    return { width: width, height: height, scroll: scroll };
}
function getTopDelta(top, overlayHeight, container, padding) {
    var containerDimensions = getContainerDimensions(container);
    var containerScroll = containerDimensions.scroll;
    var containerHeight = containerDimensions.height;
    var topEdgeOffset = top - padding - containerScroll;
    var bottomEdgeOffset = top + padding - containerScroll + overlayHeight;
    if (topEdgeOffset < 0) {
        return -topEdgeOffset;
    }
    else if (bottomEdgeOffset > containerHeight) {
        return containerHeight - bottomEdgeOffset;
    }
    else {
        return 0;
    }
}
function getLeftDelta(left, overlayWidth, container, padding) {
    var containerDimensions = getContainerDimensions(container);
    var containerWidth = containerDimensions.width;
    var leftEdgeOffset = left - padding;
    var rightEdgeOffset = left + padding + overlayWidth;
    if (leftEdgeOffset < 0) {
        return -leftEdgeOffset;
    }
    else if (rightEdgeOffset > containerWidth) {
        return containerWidth - rightEdgeOffset;
    }
    return 0;
}
function calculatePosition(placement, overlayNode, target, container, padding, customOffset) {
    if (padding === void 0) { padding = 0; }
    if (customOffset === void 0) { customOffset = [0, 0]; }
    var childOffset = container.tagName === 'BODY'
        ? offset(target)
        : position(target, container);
    var _a = offset(overlayNode), overlayHeight = _a.height, overlayWidth = _a.width;
    var clip = container.getBoundingClientRect();
    var clip2 = overlayNode.getBoundingClientRect();
    var scaleX = overlayNode.offsetWidth
        ? clip2.width / overlayNode.offsetWidth
        : 1;
    var scaleY = overlayNode.offsetHeight
        ? clip2.height / overlayNode.offsetHeight
        : 1;
    // auto 尝试四个方向对齐。
    var isAuto = placement === 'auto';
    // 兜底方向
    var autoDefaultPlacement = 'left-bottom-left-top';
    placement = isAuto
        ? "left-bottom-left-top right-bottom-right-top left-top-left-bottom right-top-right-bottom ".concat(autoDefaultPlacement)
        : placement;
    var positionLeft = 0, positionTop = 0, arrowOffsetLeft = '', arrowOffsetTop = '', activePlacement = placement;
    if (~placement.indexOf('-')) {
        var tests = placement.split(/\s+/);
        // 收集可见方向
        var visiblePlacement = {};
        while (tests.length) {
            var current = (activePlacement = tests.shift());
            // 自动对齐模式下，当四个方向都无法完全可见时
            // 根据之前的计算结果，使用收集的可见方向作为兜底，避免完全不可见
            if (isAuto && tests.length === 0) {
                var _b = __read(autoDefaultPlacement.split('-'), 4), _atX = _b[0], _atY = _b[1], _myX = _b[2], _myY = _b[3];
                var _c = visiblePlacement.atX, atX_1 = _c === void 0 ? _atX : _c, _d = visiblePlacement.atY, atY_1 = _d === void 0 ? _atY : _d, _e = visiblePlacement.myX, myX_1 = _e === void 0 ? _myX : _e, _f = visiblePlacement.myY, myY_1 = _f === void 0 ? _myY : _f;
                current = activePlacement = [atX_1, atY_1, myX_1, myY_1].join('-');
            }
            var _g = __read(current.split('-'), 4), atX = _g[0], atY = _g[1], myX = _g[2], myY = _g[3];
            myX = myX || atX;
            myY = myY || atY;
            positionLeft =
                atX === 'left'
                    ? childOffset.left
                    : atX === 'right'
                        ? childOffset.left + childOffset.width
                        : childOffset.left + childOffset.width / 2;
            positionTop =
                atY === 'top'
                    ? childOffset.top
                    : atY === 'bottom'
                        ? childOffset.top + childOffset.height
                        : childOffset.top + childOffset.height / 2;
            positionLeft -=
                myX === 'left' ? 0 : myX === 'right' ? overlayWidth : overlayWidth / 2;
            positionTop -=
                myY === 'top'
                    ? 0
                    : myY === 'bottom'
                        ? overlayHeight
                        : overlayHeight / 2;
            // 如果还有其他可选项，则做位置判断，是否在可视区域，不完全在则继续看其他定位情况。
            if (tests.length) {
                var transformed = {
                    x: clip.x + positionLeft / scaleX,
                    y: clip.y + positionTop / scaleY,
                    width: overlayWidth,
                    height: overlayHeight
                };
                var visibleX = false;
                var visibleY = false;
                if (transformed.x > 0 &&
                    transformed.x + transformed.width < window.innerWidth) {
                    visibleX = true;
                    !visiblePlacement.atX && (visiblePlacement.atX = atX);
                    !visiblePlacement.myX && (visiblePlacement.myX = myX);
                }
                if (transformed.y > 0 &&
                    transformed.y + transformed.height < window.innerHeight) {
                    visibleY = true;
                    !visiblePlacement.atY && (visiblePlacement.atY = atY);
                    !visiblePlacement.myY && (visiblePlacement.myY = myY);
                }
                if (visibleX && visibleY) {
                    break;
                }
            }
        }
        // todo arrow 位置支持
    }
    else if (placement === 'left' || placement === 'right') {
        // atX = placement;
        // atY = myY = 'center';
        // myX = placement === 'left' ? 'right' : 'left';
        if (placement === 'left') {
            positionLeft = childOffset.left - overlayWidth;
        }
        else {
            positionLeft = childOffset.left + childOffset.width;
        }
        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;
        var topDelta = getTopDelta(positionTop, overlayHeight, container, padding);
        positionTop += topDelta;
        arrowOffsetTop = 50 * (1 - (2 * topDelta) / overlayHeight) + '%';
    }
    else if (placement === 'top' || placement === 'bottom') {
        // atY = placement;
        // atX = myX = 'center';
        // myY = placement === 'top' ? 'bottom': 'top';
        if (placement === 'top') {
            positionTop = childOffset.top - overlayHeight;
        }
        else {
            positionTop = childOffset.top + childOffset.height;
        }
        positionLeft = childOffset.left + (childOffset.width - overlayWidth) / 2;
        var leftDelta = getLeftDelta(positionLeft, overlayWidth, container, padding);
        positionLeft += leftDelta;
        arrowOffsetLeft = 50 * (1 - (2 * leftDelta) / overlayHeight) + '%';
    }
    else if (placement === 'center') {
        // atX = atY = myX = myY = 'center';
        positionLeft = childOffset.left + (childOffset.width - overlayWidth) / 2;
        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;
        arrowOffsetLeft = arrowOffsetTop = void 0;
    }
    else {
        throw new Error("calcOverlayPosition(): No such placement of \"".concat(placement, "\" found."));
    }
    var _h = __read(customOffset, 2), _j = _h[0], offSetX = _j === void 0 ? 0 : _j, _k = _h[1], offSetY = _k === void 0 ? 0 : _k;
    return {
        positionLeft: (positionLeft + offSetX) / scaleX,
        positionTop: (positionTop + offSetY) / scaleY,
        arrowOffsetLeft: (arrowOffsetLeft + offSetX) / scaleX,
        arrowOffsetTop: (arrowOffsetTop + offSetY) / scaleY,
        activePlacement: activePlacement
    };
}
/**
 * 专门用来获取样式的像素值，默认返回 0
 */
function getStyleNumber(element, styleName) {
    if (!element) {
        return 0;
    }
    return (parseInt(getComputedStyle(element).getPropertyValue(styleName), 10) || 0);
}
/** 根据关键字高亮显示文本内容 */
function renderTextByKeyword(rendererText, curKeyword) {
    if (!rendererText || typeof rendererText !== 'string') {
        return rendererText;
    }
    if (curKeyword && ~rendererText.indexOf(curKeyword)) {
        var keywordStartIndex = rendererText.indexOf(curKeyword);
        var keywordEndIndex = keywordStartIndex + curKeyword.length;
        return (React.createElement("span", null,
            rendererText.substring(0, keywordStartIndex),
            React.createElement("span", { className: "is-keyword" }, curKeyword),
            rendererText.substring(keywordEndIndex)));
    }
    else {
        return rendererText;
    }
}

export { calculatePosition, getContainer, getStyleNumber, ownerDocument, renderTextByKeyword };
