/**
 * amis-core v3.6.3
 * Copyright 2018-2023 fex
 */

import { __assign } from 'tslib';
import { types } from 'mobx-state-tree';
import '../utils/helper.js';
import 'amis-formula';
import 'moment';
import { createObject, extendObject, cloneObject, setVariable, deleteVariable, extractObjectChain, createObjectFromChain } from '../utils/object.js';
import { getVariable } from '../utils/getVariable.js';
import { dataMapping } from '../utils/dataMapping.js';
import '../utils/filter.js';
import { SimpleMap } from '../utils/SimpleMap.js';
import { StoreNode } from './node.js';
import '../utils/api.js';
import '../utils/ColorScale.js';
import 'react';
import 'lodash/chunk';
import '../utils/DataSchema.js';
import '../utils/DataScope.js';
import '../utils/debug.js';
import 'react-dom';
import '../utils/errors.js';
import '../utils/tpl.js';
import 'lodash/isPlainObject';
import 'lodash/isObject';
import 'lodash/isString';
import 'lodash/isBoolean';
import '../utils/image.js';
import 'lodash/isEqual';
import '../actions/Action.js';
import 'lodash/debounce';
import 'lodash/cloneDeep';
import '../utils/resize-sensor.js';
import 'react-overlays/useRootClose';
import 'lodash/mapValues';
import 'lodash/camelCase';
import 'lodash/map';
import 'lodash/isEmpty';
import 'lodash/kebabCase';
import 'uncontrollable';
import 'hoist-non-react-statics';
import '../utils/validations.js';
import '../utils/resolveCondition.js';
import 'mobx';
import '../utils/Animation.js';

var iRendererStore = StoreNode.named('iRendererStore')
    .props({
    hasRemoteData: types.optional(types.boolean, false),
    data: types.optional(types.frozen(), {}),
    initedAt: 0,
    updatedAt: 0,
    pristine: types.optional(types.frozen(), {}),
    action: types.optional(types.frozen(), undefined),
    dialogOpen: false,
    dialogData: types.optional(types.frozen(), undefined),
    drawerOpen: false,
    drawerData: types.optional(types.frozen(), undefined)
})
    .views(function (self) { return ({
    getValueByName: function (name, canAccessSuper) {
        if (canAccessSuper === void 0) { canAccessSuper = true; }
        return getVariable(self.data, name, canAccessSuper);
    },
    getPristineValueByName: function (name) {
        return getVariable(self.pristine, name, false);
    }
}); })
    .actions(function (self) {
    var dialogCallbacks = new SimpleMap();
    var dialogScoped = null;
    var drawerScoped = null;
    var top = null;
    return {
        setTopStore: function (value) {
            top = value;
        },
        initData: function (data, skipSetPristine) {
            if (data === void 0) { data = {}; }
            if (skipSetPristine === void 0) { skipSetPristine = false; }
            self.initedAt = Date.now();
            !skipSetPristine && (self.pristine = data);
            self.data = data;
        },
        reset: function () {
            self.data = self.pristine;
        },
        updateData: function (data, tag, replace) {
            if (data === void 0) { data = {}; }
            var prev = self.data;
            var newData;
            if (tag) {
                var proto = createObject(self.data.__super || null, tag);
                newData = createObject(proto, __assign(__assign({}, (replace ? {} : self.data)), data));
            }
            else {
                newData = extendObject(self.data, data, !replace);
            }
            Object.defineProperty(newData, '__prev', {
                value: __assign({}, prev),
                enumerable: false,
                configurable: false,
                writable: false
            });
            self.data = newData;
        },
        changeValue: function (name, value, changePristine, force, otherModifier) {
            if (!name) {
                return;
            }
            var origin = getVariable(self.data, name, false);
            if (value === origin && !force) {
                return;
            }
            var prev = self.data;
            var data = cloneObject(self.data);
            if (prev.hasOwnProperty('__prev')) {
                // 基于之前的 __prev 改
                var prevData = cloneObject(prev.__prev);
                setVariable(prevData, name, origin);
                Object.defineProperty(data, '__prev', {
                    value: prevData,
                    enumerable: false,
                    configurable: false,
                    writable: false
                });
            }
            else {
                Object.defineProperty(data, '__prev', {
                    value: __assign({}, prev),
                    enumerable: false,
                    configurable: false,
                    writable: false
                });
            }
            if (value === undefined) {
                deleteVariable(data, name);
            }
            else {
                setVariable(data, name, value);
            }
            otherModifier === null || otherModifier === void 0 ? void 0 : otherModifier(data);
            if (changePristine) {
                var pristine = cloneObject(self.pristine);
                setVariable(pristine, name, value);
                otherModifier === null || otherModifier === void 0 ? void 0 : otherModifier(pristine);
                self.pristine = pristine;
            }
            if (!data.__pristine) {
                Object.defineProperty(data, '__pristine', {
                    value: self.pristine,
                    enumerable: false,
                    configurable: false,
                    writable: false
                });
            }
            self.data = data;
        },
        setCurrentAction: function (action) {
            self.action = action;
        },
        openDialog: function (ctx, additonal, callback, scoped) {
            var chain = extractObjectChain(ctx);
            chain.length === 1 && chain.unshift(self.data);
            if (additonal) {
                chain.splice(chain.length - 1, 0, additonal);
            }
            var data = createObjectFromChain(chain);
            if (self.action.dialog && self.action.dialog.data) {
                self.dialogData = createObjectFromChain([
                    top === null || top === void 0 ? void 0 : top.context,
                    dataMapping(self.action.dialog.data, data)
                ]);
                var clonedAction = __assign(__assign({}, self.action), { dialog: __assign({}, self.action.dialog) });
                delete clonedAction.dialog.data;
                self.action = clonedAction;
            }
            else {
                self.dialogData = data;
            }
            self.dialogOpen = true;
            callback && dialogCallbacks.set(self.dialogData, callback);
            dialogScoped = scoped || null;
        },
        closeDialog: function (result) {
            var callback = dialogCallbacks.get(self.dialogData);
            self.dialogOpen = false;
            dialogScoped = null;
            if (callback) {
                dialogCallbacks.delete(self.dialogData);
                setTimeout(function () { return callback(result); }, 200);
            }
        },
        openDrawer: function (ctx, additonal, callback, scoped) {
            var chain = extractObjectChain(ctx);
            chain.length === 1 && chain.unshift(self.data);
            if (additonal) {
                chain.splice(chain.length - 1, 0, additonal);
            }
            var data = createObjectFromChain(chain);
            if (self.action.drawer.data) {
                self.drawerData = createObjectFromChain([
                    top === null || top === void 0 ? void 0 : top.context,
                    dataMapping(self.action.drawer.data, data)
                ]);
                var clonedAction = __assign(__assign({}, self.action), { drawer: __assign({}, self.action.drawer) });
                delete clonedAction.drawer.data;
                self.action = clonedAction;
            }
            else {
                self.drawerData = data;
            }
            self.drawerOpen = true;
            if (callback) {
                dialogCallbacks.set(self.drawerData, callback);
            }
            drawerScoped = scoped || null;
        },
        closeDrawer: function (result) {
            var callback = dialogCallbacks.get(self.drawerData);
            self.drawerOpen = false;
            drawerScoped = null;
            if (callback) {
                dialogCallbacks.delete(self.drawerData);
                setTimeout(function () { return callback(result); }, 200);
            }
        },
        getDialogScoped: function () {
            return dialogScoped;
        },
        getDrawerScoped: function () {
            return drawerScoped;
        }
    };
});
// export type SIRendererStore = typeof iRendererStore.SnapshotType;

export { iRendererStore };
