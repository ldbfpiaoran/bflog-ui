/**
 * amis-core v3.6.3
 * Copyright 2018-2023 fex
 */

import { __extends, __assign, __awaiter, __generator } from 'tslib';
import React from 'react';
import debounce from 'lodash/debounce';
import isEqual from 'lodash/isEqual';
import { ComboStore } from '../store/combo.js';
import { guid, promisify, changedEffect } from '../utils/helper.js';
import { isExpression, FormulaExec, replaceExpression, isNeedFormula } from '../utils/formula.js';
import { ScopedContext } from '../Scoped.js';
import { FormItemStore } from '../store/formItem.js';
import { isAlive } from 'mobx-state-tree';
import { observer } from 'mobx-react';
import hoistNonReactStatic from 'hoist-non-react-statics';
import { withRootStore } from '../WithRootStore.js';
import { TableStore } from '../store/table.js';
import pick from 'lodash/pick';
import { callStrFunction } from '../utils/api.js';
import '../utils/ColorScale.js';
import 'lodash/chunk';
import 'amis-formula';
import { tokenize } from '../utils/tokenize.js';
import 'lodash/isPlainObject';
import { getVariable } from '../utils/getVariable.js';
import '../utils/DataSchema.js';
import '../utils/DataScope.js';
import 'moment';
import '../utils/debug.js';
import 'react-dom';
import '../utils/errors.js';
import '../utils/tpl.js';
import '../utils/filter.js';
import 'lodash/isObject';
import '../utils/image.js';
import '../actions/Action.js';
import 'lodash/cloneDeep';
import '../utils/resize-sensor.js';
import 'react-overlays/useRootClose';
import '../utils/SimpleMap.js';
import 'lodash/mapValues';
import 'lodash/camelCase';
import 'lodash/map';
import 'lodash/isEmpty';
import 'lodash/kebabCase';
import 'uncontrollable';
import '../utils/validations.js';
import '../utils/resolveCondition.js';
import 'mobx';
import '../utils/Animation.js';

function wrapControl(ComposedComponent) {
    var _a;
    var result = hoistNonReactStatic(withRootStore(observer((_a = /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1(props) {
                var _this = this;
                var _a;
                _this = _super.call(this, props) || this;
                _this.value = undefined;
                _this.lazyEmitChange = debounce(_this.emitChange.bind(_this), 250, {
                    trailing: true,
                    leading: false
                });
                var _b = _this.props, form = _b.formStore, formItem = _b.formItem, rootStore = _b.rootStore, store = _b.store, onChange = _b.onChange, data = _b.data, inputGroupControl = _b.inputGroupControl, colIndex = _b.colIndex, rowIndex = _b.rowIndex, _c = _b.$schema, id = _c.id, type = _c.type, required = _c.required, validations = _c.validations, validationErrors = _c.validationErrors, unique = _c.unique, value = _c.value, extraName = _c.extraName; _c.multiple; var delimiter = _c.delimiter, valueField = _c.valueField, labelField = _c.labelField, joinValues = _c.joinValues, extractValue = _c.extractValue, selectFirst = _c.selectFirst, autoFill = _c.autoFill, clearValueOnHidden = _c.clearValueOnHidden, validateApi = _c.validateApi, minLength = _c.minLength, maxLength = _c.maxLength, validateOnChange = _c.validateOnChange, label = _c.label, pagination = _c.pagination;
                _this.getValue = _this.getValue.bind(_this);
                _this.setValue = _this.setValue.bind(_this);
                _this.handleChange = _this.handleChange.bind(_this);
                _this.setPrinstineValue = _this.setPrinstineValue.bind(_this);
                _this.controlRef = _this.controlRef.bind(_this);
                _this.handleBlur = _this.handleBlur.bind(_this);
                _this.validate = _this.validate.bind(_this);
                _this.flushChange = _this.flushChange.bind(_this);
                _this.renderChild = _this.renderChild.bind(_this);
                var name = _this.props.$schema.name;
                // 如果 name 是表达式
                // 扩充 each 用法
                if (isExpression(name)) {
                    name = tokenize(name, data);
                }
                if (!name) {
                    return _this;
                }
                var propValue = _this.props.value;
                var model = rootStore.addStore({
                    id: guid(),
                    path: _this.props.$path,
                    storeType: FormItemStore.name,
                    parentId: store === null || store === void 0 ? void 0 : store.id,
                    name: name,
                    colIndex: colIndex !== undefined ? colIndex : undefined,
                    rowIndex: rowIndex !== undefined ? rowIndex : undefined
                });
                _this.model = model;
                // @issue 打算干掉这个
                formItem === null || formItem === void 0 ? void 0 : formItem.addSubFormItem(model);
                model.config(__assign(__assign({}, pick(__assign(__assign({}, ComposedComponent.defaultProps), _this.props.$schema), ['multiple'])), { id: id, type: type, required: props.required || required, unique: unique, value: value, isValueSchemaExp: isExpression(value), rules: validations, messages: validationErrors, delimiter: delimiter, valueField: valueField, labelField: labelField, joinValues: joinValues, extractValue: extractValue, selectFirst: selectFirst, autoFill: autoFill, clearValueOnHidden: clearValueOnHidden, validateApi: validateApi, minLength: minLength, maxLength: maxLength, validateOnChange: validateOnChange, label: label, inputGroupControl: inputGroupControl, extraName: extraName, pagination: pagination }));
                // issue 这个逻辑应该在 combo 里面自己实现。
                if (_this.model.unique &&
                    ((_a = form === null || form === void 0 ? void 0 : form.parentStore) === null || _a === void 0 ? void 0 : _a.storeType) === ComboStore.name) {
                    var combo = form.parentStore;
                    combo.bindUniuqueItem(model);
                }
                if (propValue !== undefined && propValue !== null) {
                    // 同步 value: 优先使用 props 中的 value
                    model.changeTmpValue(propValue, 'controlled');
                    model.setIsControlled(true);
                }
                else {
                    var isExp = isExpression(value);
                    if (isExp) {
                        model.changeTmpValue(FormulaExec['formula'](value, data), // 对组件默认值进行运算
                        'formulaChanged');
                    }
                    else {
                        var initialValue = model.extraName
                            ? [
                                store === null || store === void 0 ? void 0 : store.getValueByName(model.name, form === null || form === void 0 ? void 0 : form.canAccessSuperData),
                                store === null || store === void 0 ? void 0 : store.getValueByName(model.extraName, form === null || form === void 0 ? void 0 : form.canAccessSuperData)
                            ]
                            : store === null || store === void 0 ? void 0 : store.getValueByName(model.name, form === null || form === void 0 ? void 0 : form.canAccessSuperData);
                        if (model.extraName &&
                            initialValue.every(function (item) { return item === undefined; })) {
                            initialValue = undefined;
                        }
                        model.changeTmpValue(initialValue !== null && initialValue !== void 0 ? initialValue : replaceExpression(value), typeof initialValue !== 'undefined'
                            ? 'initialValue'
                            : 'defaultValue');
                    }
                }
                if (onChange &&
                    value !== undefined &&
                    model.tmpValue !== undefined) {
                    // 组件默认值支持表达式需要: 避免初始化时上下文中丢失组件默认值
                    if (model.extraName) {
                        var values = model.splitExtraValue(model.tmpValue);
                        onChange(values[0], model.name, false, true);
                        onChange(values[1], model.extraName, false, true);
                    }
                    else {
                        onChange(model.tmpValue, model.name, false, true);
                    }
                }
                else if (onChange &&
                    typeof propValue === 'undefined' &&
                    typeof (store === null || store === void 0 ? void 0 : store.getValueByName(model.name, false)) === 'undefined' &&
                    // todo 后续再优化这个判断，
                    // 目前 input-table 中默认值会给冲掉，所以加上这个判断
                    // 对应 issue 为 https://github.com/baidu/amis/issues/2674
                    (store === null || store === void 0 ? void 0 : store.storeType) !== TableStore.name) {
                    // 如果没有初始值，通过 onChange 设置过去
                    if (model.extraName) {
                        var values = model.splitExtraValue(model.tmpValue);
                        onChange(values[0], model.name, false, true);
                        onChange(values[1], model.extraName, false, true);
                    }
                    else {
                        onChange(model.tmpValue, model.name, false, true);
                    }
                }
                return _this;
            }
            class_1.prototype.componentDidMount = function () {
                var _this = this;
                var _a = this.props; _a.store; _a.formStore; var validate = _a.$schema.validate, addHook = _a.addHook;
                // 提交前先把之前的 lazyEmit 执行一下。
                this.hook3 = function () {
                    _this.lazyEmitChange.flush();
                };
                addHook === null || addHook === void 0 ? void 0 : addHook(this.hook3, 'flush');
                var formItem = this.model;
                if (formItem && validate) {
                    var finalValidate_1 = promisify(validate.bind(this.control));
                    this.hook2 = function () {
                        formItem.clearError('control:valdiate');
                        return finalValidate_1(_this.props.data, _this.getValue(), formItem.name).then(function (ret) {
                            if ((typeof ret === 'string' || Array.isArray(ret)) && ret) {
                                formItem.addError(ret, 'control:valdiate');
                            }
                        });
                    };
                    addHook === null || addHook === void 0 ? void 0 : addHook(this.hook2);
                }
            };
            class_1.prototype.componentDidUpdate = function (prevProps) {
                var _a, _b, _c;
                var props = this.props;
                var model = this.model;
                if (!model) {
                    return;
                }
                changedEffect([
                    'id',
                    'validations',
                    'validationErrors',
                    'value',
                    'defaultValue',
                    'required',
                    'unique',
                    'multiple',
                    'delimiter',
                    'valueField',
                    'labelField',
                    'joinValues',
                    'extractValue',
                    'selectFirst',
                    'autoFill',
                    'clearValueOnHidden',
                    'validateApi',
                    'minLength',
                    'maxLength',
                    'label',
                    'extraName',
                    'pagination'
                ], prevProps.$schema, props.$schema, function (changes) {
                    model.config(__assign(__assign({}, changes), { 
                        // todo 优化后面两个
                        isValueSchemaExp: isExpression(props.$schema.value), inputGroupControl: props === null || props === void 0 ? void 0 : props.inputGroupControl }));
                });
                if (props.required !== prevProps.required) {
                    model.config({
                        required: props.required
                    });
                }
                // 此处需要同时考虑 defaultValue 和 value
                if (typeof props.value !== 'undefined') {
                    // 渲染器中的 value 优先
                    if (!isEqual(props.value, prevProps.value) &&
                        !isEqual(props.value, model.tmpValue)) {
                        // 外部直接传入的 value 无需执行运算器
                        model.changeTmpValue(props.value, 'controlled');
                    }
                }
                else if (typeof props.defaultValue !== 'undefined' &&
                    isExpression(props.defaultValue) &&
                    (!isEqual(props.defaultValue, prevProps.defaultValue) ||
                        (props.data !== prevProps.data &&
                            isNeedFormula(props.defaultValue, props.data, prevProps.data)))) {
                    var curResult = FormulaExec['formula'](props.defaultValue, props.data);
                    var prevResult = FormulaExec['formula'](prevProps.defaultValue, prevProps.data);
                    if (!isEqual(curResult, prevResult) &&
                        !isEqual(curResult, model.tmpValue)) {
                        // 识别上下文变动、自身数值变动、公式运算结果变动
                        model.changeTmpValue(curResult, 'formulaChanged');
                        if (model.extraName) {
                            var values = model.splitExtraValue(curResult);
                            (_a = props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, values[0], model.name, false);
                            (_b = props.onChange) === null || _b === void 0 ? void 0 : _b.call(props, values[1], model.extraName, false);
                        }
                        else {
                            (_c = props.onChange) === null || _c === void 0 ? void 0 : _c.call(props, curResult, model.name, false);
                        }
                    }
                }
                else {
                    // value 非公式表达式时，name 值优先，若 defaultValue 主动变动时，则使用 defaultValue
                    if (
                    // 然后才是查看关联的 name 属性值是否变化
                    props.data !== prevProps.data &&
                        (!model.emitedValue ||
                            isEqual(model.emitedValue, model.tmpValue))) {
                        model.changeEmitedValue(undefined);
                        var valueByName = model.extraName
                            ? [
                                getVariable(props.data, model.name, false),
                                getVariable(props.data, model.extraName, false)
                            ]
                            : getVariable(props.data, model.name, false);
                        if (!isEqual(valueByName, model.extraName
                            ? model.splitExtraValue(model.tmpValue)
                            : model.tmpValue) &&
                            (!isEqual(model.extraName ? valueByName[0] : valueByName, getVariable(prevProps.data, model.name, false)) ||
                                // extraName
                                (model.extraName &&
                                    !isEqual(valueByName[1], getVariable(prevProps.data, model.extraName, false))))) {
                            model.changeTmpValue(valueByName, props.formInited && !prevProps.formInited
                                ? 'formInited'
                                : 'dataChanged');
                            this.checkValidate();
                        }
                    }
                }
            };
            class_1.prototype.componentWillUnmount = function () {
                var _a, _b, _c, _d, _e, _f, _g;
                this.hook && ((_b = (_a = this.props).removeHook) === null || _b === void 0 ? void 0 : _b.call(_a, this.hook));
                this.hook2 && ((_d = (_c = this.props).removeHook) === null || _d === void 0 ? void 0 : _d.call(_c, this.hook2));
                this.hook3 && ((_f = (_e = this.props).removeHook) === null || _f === void 0 ? void 0 : _f.call(_e, this.hook3, 'flush'));
                // this.lazyEmitChange.flush();
                this.lazyEmitChange.cancel();
                (_g = this.reaction) === null || _g === void 0 ? void 0 : _g.call(this);
                this.disposeModel();
            };
            class_1.prototype.disposeModel = function () {
                var _a;
                var _b = this.props, form = _b.formStore, formItem = _b.formItem, rootStore = _b.rootStore;
                if (this.model &&
                    this.model.unique &&
                    (form === null || form === void 0 ? void 0 : form.parentStore) &&
                    (form === null || form === void 0 ? void 0 : form.parentStore.storeType) === ComboStore.name) {
                    var combo = form.parentStore;
                    combo.unBindUniuqueItem(this.model);
                }
                if (this.model) {
                    formItem &&
                        isAlive(formItem) &&
                        formItem.removeSubFormItem(this.model);
                    this.model.clearValueOnHidden &&
                        ((_a = this.model.form) === null || _a === void 0 ? void 0 : _a.deleteValueByName(this.model.name));
                    isAlive(rootStore) && rootStore.removeStore(this.model);
                }
                delete this.model;
            };
            class_1.prototype.controlRef = function (control) {
                var _this = this;
                var _a = this.props, addHook = _a.addHook, removeHook = _a.removeHook; _a.formStore;
                // 因为 control 有可能被 n 层 hoc 包裹。
                while (control && control.getWrappedInstance) {
                    control = control.getWrappedInstance();
                }
                if (control && control.validate && this.model) {
                    var formItem_1 = this.model;
                    var validate_1 = promisify(control.validate.bind(control));
                    this.hook = function () {
                        formItem_1.clearError('component:valdiate');
                        return validate_1(_this.props.data, _this.getValue(), formItem_1.name).then(function (ret) {
                            if ((typeof ret === 'string' || Array.isArray(ret)) && ret) {
                                formItem_1.setError(ret, 'component:valdiate');
                            }
                        });
                    };
                    addHook === null || addHook === void 0 ? void 0 : addHook(this.hook);
                }
                else if (!control && this.hook) {
                    removeHook === null || removeHook === void 0 ? void 0 : removeHook(this.hook);
                    this.hook = undefined;
                }
                // 注册到 Scoped 上
                var originRef = this.control;
                this.control = control;
                var scoped = this.context;
                if (control) {
                    scoped.registerComponent(this.control);
                }
                else if (originRef) {
                    scoped.unRegisterComponent(originRef);
                }
            };
            class_1.prototype.checkValidate = function () {
                var _a;
                if (!this.model)
                    return; // 如果 model 为 undefined 则直接返回
                var validated = this.model.validated;
                var _b = this.props, formSubmited = _b.formSubmited, validateOnChange = _b.validateOnChange;
                if (
                // 如果配置了 minLength 或者 maxLength 就切成及时验证
                // this.model.rules.minLength ||
                // this.model.rules.maxLength ||
                validateOnChange === true ||
                    (validateOnChange !== false && (formSubmited || validated))) {
                    this.validate();
                }
                else if (validateOnChange === false) {
                    (_a = this.model) === null || _a === void 0 ? void 0 : _a.reset();
                }
            };
            class_1.prototype.validate = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var _a, form, data, formItemDispatchEvent, result, combo, group, validPromises, valid;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                if (!this.model)
                                    return [2 /*return*/];
                                _a = this.props, form = _a.formStore, data = _a.data, formItemDispatchEvent = _a.formItemDispatchEvent;
                                if (!(this.model.unique &&
                                    (form === null || form === void 0 ? void 0 : form.parentStore) &&
                                    form.parentStore.storeType === ComboStore.name)) return [3 /*break*/, 2];
                                combo = form.parentStore;
                                group = combo.uniques.get(this.model.name);
                                validPromises = group.items.map(function (item) {
                                    return item.validate(data);
                                });
                                return [4 /*yield*/, Promise.all(validPromises)];
                            case 1:
                                result = _b.sent();
                                return [3 /*break*/, 4];
                            case 2: return [4 /*yield*/, this.model.validate(data)];
                            case 3:
                                result = [_b.sent()];
                                _b.label = 4;
                            case 4:
                                valid = !result.some(function (item) { return item === false; });
                                formItemDispatchEvent === null || formItemDispatchEvent === void 0 ? void 0 : formItemDispatchEvent(valid ? 'formItemValidateSucc' : 'formItemValidateError', data);
                                return [2 /*return*/, valid];
                        }
                    });
                });
            };
            class_1.prototype.flushChange = function () {
                this.lazyEmitChange.flush();
            };
            class_1.prototype.handleChange = function (value, submitOnChange, changeImmediately) {
                if (submitOnChange === void 0) { submitOnChange = this.props.$schema.submitOnChange; }
                if (changeImmediately === void 0) { changeImmediately = false; }
                var _a = this.props; _a.formStore; var onChange = _a.onChange, _b = _a.$schema, type = _b.type, pipeOut = _b.pipeOut, conrolChangeImmediately = _b.changeImmediately, formInited = _a.formInited, data = _a.data;
                if (!this.model ||
                    // todo 以后想办法不要強耦合类型。
                    ~[
                        'service',
                        'group',
                        'hbox',
                        'panel',
                        'grid',
                        'input-group'
                    ].indexOf(type)) {
                    onChange && onChange.apply(null, arguments);
                    return;
                }
                if (pipeOut) {
                    var oldValue = this.model.value;
                    value = callStrFunction.call(this, pipeOut, ['value', 'oldValue', 'data'], value, oldValue, data);
                }
                this.model.changeTmpValue(value, 'input');
                if (changeImmediately || conrolChangeImmediately || !formInited) {
                    this.emitChange(submitOnChange);
                }
                else {
                    // this.props.onTmpValueChange?.(value, this.model.name);
                    this.lazyEmitChange(submitOnChange);
                }
            };
            class_1.prototype.emitChange = function (submitOnChange) {
                if (submitOnChange === void 0) { submitOnChange = this.props.$schema.submitOnChange; }
                var _a = this.props, form = _a.formStore, onChange = _a.onChange, _b = _a.$schema, id = _b.id, label = _b.label, type = _b.type, onFormItemChange = _b.onChange; _b.maxLength; _b.minLength; var data = _a.data, env = _a.env; _a.validateOnChange; _a.formSubmited;
                if (!this.model) {
                    return;
                }
                var model = this.model;
                var value = this.model.tmpValue;
                var oldValue = model.extraName
                    ? [
                        getVariable(data, model.name, false),
                        getVariable(data, model.extraName, false)
                    ]
                    : getVariable(data, model.name, false);
                if (model.extraName ? isEqual(oldValue, value) : oldValue === value) {
                    return;
                }
                if (type !== 'input-password') {
                    env === null || env === void 0 ? void 0 : env.tracker({
                        eventType: 'formItemChange',
                        eventData: {
                            id: id,
                            name: model.name,
                            label: label,
                            type: type,
                            value: value
                        }
                    }, this.props);
                }
                this.model.changeEmitedValue(value);
                if ((onFormItemChange === null || onFormItemChange === void 0 ? void 0 : onFormItemChange(value, oldValue, this.model, form)) === false) {
                    return;
                }
                // onFormItemChange 可能会触发组件销毁，再次读取 this.model 为 undefined
                if (!this.model) {
                    return;
                }
                if (model.extraName) {
                    var values = model.splitExtraValue(value);
                    onChange === null || onChange === void 0 ? void 0 : onChange(values[0], model.name);
                    onChange === null || onChange === void 0 ? void 0 : onChange(values[1], model.extraName, submitOnChange === true);
                }
                else {
                    onChange === null || onChange === void 0 ? void 0 : onChange(value, model.name, submitOnChange === true);
                }
                this.checkValidate();
            };
            class_1.prototype.handleBlur = function (e) {
                var _a = this.props, onBlur = _a.onBlur, validateOnBlur = _a.$schema.validateOnBlur;
                if (validateOnBlur && this.model) {
                    this.validate();
                }
                onBlur && onBlur(e);
            };
            class_1.prototype.setPrinstineValue = function (value) {
                if (!this.model) {
                    return;
                }
                var model = this.model;
                var _a = this.props; _a.formStore; var pipeOut = _a.$schema.pipeOut, onChange = _a.onChange, oldValue = _a.value, data = _a.data;
                if (pipeOut) {
                    value = callStrFunction.call(this, pipeOut, ['value', 'oldValue', 'data'], value, oldValue, data);
                }
                if (model.extraName) {
                    var values = model.splitExtraValue(value);
                    onChange === null || onChange === void 0 ? void 0 : onChange(values[0], model.name, false, true);
                    onChange === null || onChange === void 0 ? void 0 : onChange(values[1], model.extraName, false, true);
                }
                else {
                    onChange === null || onChange === void 0 ? void 0 : onChange(value, model.name, false, true);
                }
            };
            class_1.prototype.getValue = function () {
                var _a = this.props, data = _a.formStore, control = _a.$schema;
                var value = this.model ? this.model.tmpValue : control.value;
                if (control.pipeIn) {
                    value = callStrFunction.call(this, control.pipeIn, ['value', 'data'], value, data);
                }
                return value;
            };
            // 兼容老版本用法，新版本直接用 onChange 就可以。
            class_1.prototype.setValue = function (value, key) {
                var _a;
                var onBulkChange = this.props.onBulkChange;
                if (!key || (this.model && key === this.model.name)) {
                    this.handleChange(value);
                }
                else {
                    onBulkChange &&
                        onBulkChange((_a = {},
                            _a[key] = value,
                            _a));
                }
            };
            class_1.prototype.renderChild = function (region, node, subProps) {
                if (subProps === void 0) { subProps = {}; }
                var _a = this.props, render = _a.render, data = _a.data, store = _a.store;
                var model = this.model;
                return render(region, node, __assign({ data: model
                        ? model.getMergedData(data || (store === null || store === void 0 ? void 0 : store.data))
                        : data || (store === null || store === void 0 ? void 0 : store.data) }, subProps));
            };
            class_1.prototype.render = function () {
                var _a, _b, _c;
                var _d = this.props, controlWidth = _d.controlWidth, disabled = _d.disabled, formMode = _d.formMode, control = _d.$schema, store = _d.store, data = _d.data, invisible = _d.invisible, defaultStatic = _d.defaultStatic;
                if (invisible) {
                    return null;
                }
                var value = this.getValue();
                var model = this.model;
                var injectedProps = {
                    defaultSize: controlWidth,
                    disabled: disabled !== null && disabled !== void 0 ? disabled : control.disabled,
                    static: (_b = (_a = this.props.static) !== null && _a !== void 0 ? _a : control.static) !== null && _b !== void 0 ? _b : defaultStatic,
                    formItem: this.model,
                    formMode: control.mode || formMode,
                    ref: this.controlRef,
                    data: data || (store === null || store === void 0 ? void 0 : store.data),
                    name: (_c = model === null || model === void 0 ? void 0 : model.name) !== null && _c !== void 0 ? _c : control.name,
                    value: value,
                    changeMotivation: model === null || model === void 0 ? void 0 : model.changeMotivation,
                    defaultValue: control.value,
                    formItemValue: value,
                    onChange: this.handleChange,
                    onBlur: this.handleBlur,
                    setValue: this.setValue,
                    getValue: this.getValue,
                    prinstine: model ? model.prinstine : undefined,
                    setPrinstineValue: this.setPrinstineValue,
                    onValidate: this.validate,
                    onFlushChange: this.flushChange
                    // render: this.renderChild // 如果覆盖，那么用的就是 form 上的 render，这个里面用到的 data 是比较旧的。
                    // !没了这个， tree 里的 options 渲染会出问题
                    // todo 理论上不应该影响，待确认
                    // _filteredOptions: this.model?.filteredOptions
                };
                return (React.createElement(ComposedComponent, __assign({}, this.props, injectedProps)));
            };
            return class_1;
        }(React.Component)),
        _a.displayName = "WrapControl".concat(ComposedComponent.displayName || ComposedComponent.name
            ? "(".concat(ComposedComponent.displayName || ComposedComponent.name, ")")
            : ''),
        _a.contextType = ScopedContext,
        _a.defaultProps = {},
        _a))), ComposedComponent);
    return result;
}

export { wrapControl };
