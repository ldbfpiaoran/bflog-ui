/**
 * amis-ui v3.6.3
 * Copyright 2018-2023 fex
 */

import { __spreadArray, __read, __assign, __rest } from 'tslib';
import findLastIndex from 'lodash/findLastIndex';
import find from 'lodash/find';
import { isBreakpoint } from 'amis-core';

// 当前行包含子数据
function checkChildrenRow(data, childrenColumnName) {
    return (data[childrenColumnName] &&
        Array.isArray(data[childrenColumnName]) &&
        data[childrenColumnName].length > 0);
}
// 获取当前行数据所有子行的key值
function getDataChildrenKeys(data, childrenColumnName, rowSelectionKeyField) {
    var keys = [];
    if (checkChildrenRow(data, childrenColumnName)) {
        data[childrenColumnName].forEach(function (item) {
            return (keys = __spreadArray(__spreadArray(__spreadArray([], __read(keys), false), __read(getDataChildrenKeys(item, childrenColumnName, rowSelectionKeyField)), false), [
                item[rowSelectionKeyField]
            ], false));
        });
    }
    return keys;
}
// 获取当前表格所有可以选中的行
function getAllSelectableRows(dataSource, rowSelectionKeyField, childrenColumnName, expandable, selectedRowKeys, maxSelectedLength) {
    var allRowKeys = [];
    var allRows = [];
    dataSource.forEach(function (data) {
        allRowKeys.push(data[rowSelectionKeyField]);
        allRows.push(data);
        if (!expandable && checkChildrenRow(data, childrenColumnName)) {
            allRowKeys = __spreadArray(__spreadArray([], __read(allRowKeys), false), __read(getDataChildrenKeys(data, childrenColumnName, rowSelectionKeyField)), false);
            data[childrenColumnName].forEach(function (item) { return allRows.push(item); });
        }
    });
    var restSelectedKeys = selectedRowKeys === null || selectedRowKeys === void 0 ? void 0 : selectedRowKeys.filter(function (key) { return !allRowKeys.includes(key); });
    if (maxSelectedLength && Number.isInteger(maxSelectedLength)) {
        if (restSelectedKeys.length + allRowKeys.length > maxSelectedLength) {
            var count = maxSelectedLength - restSelectedKeys.length;
            allRowKeys = allRowKeys.slice(0, count);
            allRows = allRows.slice(0, count);
        }
    }
    return { rows: allRows, rowKeys: allRowKeys, restSelectedKeys: restSelectedKeys };
}
function getSelectedRows(dataSource, selectedRowKeys, rowSelectionKeyField, childrenColumnName) {
    var selectedRows = [];
    var unSelectedRows = [];
    dataSource.forEach(function (data) {
        if (selectedRowKeys.find(function (key) { return key === data[rowSelectionKeyField]; })) {
            selectedRows.push(data);
        }
        else {
            unSelectedRows.push(data);
        }
        if (checkChildrenRow(data, childrenColumnName)) {
            var childrenSelected = getSelectedRows(data[childrenColumnName], selectedRowKeys, rowSelectionKeyField, childrenColumnName);
            selectedRows = __spreadArray(__spreadArray([], __read(selectedRows), false), __read(childrenSelected.selectedRows), false);
            unSelectedRows = __spreadArray(__spreadArray([], __read(unSelectedRows), false), __read(childrenSelected.unSelectedRows), false);
        }
    });
    return { selectedRows: selectedRows, unSelectedRows: unSelectedRows };
}
function getMaxLevelThRowSpan(columns) {
    var maxLevel = 0;
    Array.isArray(columns) &&
        columns.forEach(function (c) {
            var level = getThRowSpan(c);
            if (maxLevel < level) {
                maxLevel = level;
            }
        });
    return maxLevel;
}
function getThRowSpan(column) {
    if (!column.children || (column.children && !column.children.length)) {
        return 1;
    }
    return 1 + getMaxLevelThRowSpan(column.children);
}
function getThColSpan(column) {
    if (!column.children || (column.children && !column.children.length)) {
        return 1;
    }
    var childrenLength = 0;
    column.children.forEach(function (item) { return (childrenLength += getThColSpan(item)); });
    return childrenLength;
}
function buildColumns(columns, thColumns, tdColumns, maxLevel, depth, fixed) {
    if (columns === void 0) { columns = []; }
    if (tdColumns === void 0) { tdColumns = []; }
    if (depth === void 0) { depth = 0; }
    // 在处理表头时，如果父级column设置了fixed属性，那么所有children保持一致
    Array.isArray(columns) &&
        columns.forEach(function (column) {
            var childMaxLevel = 0;
            if (column.children) {
                childMaxLevel = getMaxLevelThRowSpan(column.children);
            }
            var newColumn = __assign(__assign({}, column), { rowSpan: childMaxLevel ? 1 : maxLevel - depth, colSpan: getThColSpan(column), depth: depth });
            var tdColumn = __assign({}, column);
            if (fixed) {
                newColumn.fixed = fixed;
                tdColumn.fixed = fixed;
            }
            if (!thColumns[depth]) {
                thColumns[depth] = [];
            }
            thColumns[depth].push(newColumn);
            if (column.children && column.children.length > 0) {
                buildColumns(column.children, thColumns, tdColumns, maxLevel, depth + 1, column.fixed);
            }
            else {
                tdColumn.children; var rest = __rest(tdColumn, ["children"]);
                tdColumns.push(rest);
            }
        });
}
function getBuildColumns(columns) {
    var filterColumns = columns.filter(function (item) { return !item.breakpoint || !isBreakpoint(item.breakpoint); });
    var thColumns = [];
    var tdColumns = [];
    buildColumns(filterColumns, thColumns, tdColumns, getMaxLevelThRowSpan(filterColumns));
    return { thColumns: thColumns, tdColumns: tdColumns };
}
function isFixedLeftColumn(fixed) {
    return fixed === true || fixed === 'left';
}
function isFixedRightColumn(fixed) {
    return fixed === 'right';
}
function getPreviousLeftWidth(doms, index, columns) {
    var width = 0;
    for (var i = 0; i < index; i++) {
        if (columns && columns[i] && isFixedLeftColumn(columns[i].fixed)) {
            var dom = doms[i];
            width += dom.offsetWidth;
        }
    }
    return width;
}
function getAfterRightWidth(doms, index, columns) {
    var width = 0;
    for (var i = doms.length - 0; i > index; i--) {
        if (columns && columns[i] && isFixedRightColumn(columns[i].fixed)) {
            var dom = doms[i];
            width += dom.offsetWidth;
        }
    }
    return width;
}
// 更新一个tr下的td的left和class
function updateFixedRow(row, columns, cx) {
    var _a, _b, _c;
    var children = (row === null || row === void 0 ? void 0 : row.children) || [];
    for (var i = 0; i < children.length; i++) {
        var dom = children[i];
        dom.style.removeProperty('left');
        var fixed = columns[i] ? columns[i].fixed || '' : '';
        if (isFixedLeftColumn(fixed)) {
            dom.style.left =
                i > 0 ? getPreviousLeftWidth(children, i, columns) + 'px' : '0';
        }
        else if (isFixedRightColumn(fixed)) {
            dom.style.right =
                i < children.length - 1
                    ? getAfterRightWidth(children, i, columns) + 'px'
                    : '0';
        }
        dom.classList.remove(cx('Table-cell-fix-left-last'));
        dom.classList.remove(cx('Table-cell-fix-right-first'));
        dom.classList.remove(cx('Table-cell-fix-right-first-prev'));
    }
    // 最后一个左fixed的添加样式
    var leftIndex = findLastIndex(columns, function (column) {
        return isFixedLeftColumn(column.fixed);
    });
    if (leftIndex > -1) {
        (_a = children[leftIndex]) === null || _a === void 0 ? void 0 : _a.classList.add(cx('Table-cell-fix-left-last'));
    }
    // 第一个右fixed的添加样式
    var rightIndex = columns.findIndex(function (column) {
        return isFixedRightColumn(column.fixed);
    });
    if (rightIndex > -1) {
        (_b = children[rightIndex]) === null || _b === void 0 ? void 0 : _b.classList.add(cx('Table-cell-fix-right-first'));
        if (rightIndex > 0) {
            (_c = children[rightIndex - 1]) === null || _c === void 0 ? void 0 : _c.classList.add(cx('Table-cell-fix-right-first-prev'));
        }
    }
}
function hasFixedColumn(columns) {
    return find(columns, function (column) { return column.fixed; });
}
function levelsSplit(level) {
    if (!level) {
        return [];
    }
    return level.split(',').map(function (l) { return +l; });
}

export { buildColumns, checkChildrenRow, getAllSelectableRows, getBuildColumns, getDataChildrenKeys, getMaxLevelThRowSpan, getSelectedRows, getThColSpan, getThRowSpan, hasFixedColumn, levelsSplit, updateFixedRow };
